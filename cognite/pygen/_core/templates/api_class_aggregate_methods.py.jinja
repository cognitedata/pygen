    @overload
    def aggregate(
        self,
        aggregations: Aggregations
        | dm.aggregations.MetricAggregation
        | Sequence[Aggregations]
        | Sequence[dm.aggregations.MetricAggregation],
        property: {{ data_class.field_names }} | Sequence[{{ data_class.field_names }}] | None = None,
        group_by: None = None,{% if data_class.has_text_field %}
        query: str | None = None,
        search_properties: {{ data_class.text_field_names }} | Sequence[{{ data_class.text_field_names }}] | None = None,{% endif %}{% for parm in list_method.parameters %}
        {{ parm.name }}: {{ parm.annotation }} = {{ parm.default }},{% endfor %}
        limit: int = DEFAULT_LIMIT_READ,
        filter: dm.Filter | None = None,
    ) -> list[dm.aggregations.AggregatedNumberedValue]:
        ...

    @overload
    def aggregate(
        self,
        aggregations: Aggregations
        | dm.aggregations.MetricAggregation
        | Sequence[Aggregations]
        | Sequence[dm.aggregations.MetricAggregation],
        property: {{ data_class.field_names }} | Sequence[{{ data_class.field_names }}] | None = None,
        group_by: {{ data_class.field_names }} | Sequence[{{ data_class.field_names }}] = None,{% if data_class.has_text_field %}
        query: str | None = None,
        search_properties: {{ data_class.text_field_names }} | Sequence[{{ data_class.text_field_names }}] | None = None,{% endif %}{% for parm in list_method.parameters %}
        {{ parm.name }}: {{ parm.annotation }} = {{ parm.default }},{% endfor %}
        limit: int = DEFAULT_LIMIT_READ,
        filter: dm.Filter | None = None,
    ) -> InstanceAggregationResultList:
        ...

    def aggregate(
        self,
        aggregate: Aggregations
        | dm.aggregations.MetricAggregation
        | Sequence[Aggregations]
        | Sequence[dm.aggregations.MetricAggregation],
        property: {{ data_class.field_names }} | Sequence[{{ data_class.field_names }}] | None = None,
        group_by: {{ data_class.field_names }} | Sequence[{{ data_class.field_names }}] | None = None,{% if data_class.has_text_field %}
        query: str | None = None,
        search_property: {{ data_class.text_field_names }} | Sequence[{{ data_class.text_field_names }}] | None = None,{% endif %}{% for parm in list_method.parameters %}
        {{ parm.name }}: {{ parm.annotation }} = {{ parm.default }},{% endfor %}
        limit: int = DEFAULT_LIMIT_READ,
        filter: dm.Filter | None = None,
    ) -> list[dm.aggregations.AggregatedNumberedValue] | InstanceAggregationResultList:
        """Aggregate data across {{ data_class.doc_list_name }}

        Args:
            aggregate: The aggregation to perform.
            property: The property to perform aggregation on.
            group_by: The property to group by when doing the aggregation.{% if data_class.has_text_field %}
            query: The query to search for in the text field.
            search_property: The text field to search in.{% endif %}{% for parm in list_method.parameters %}
            {{ parm.name }}: {{ parm.description }}{% endfor %}
            limit: Maximum number of {{ data_class.doc_list_name }} to return. Defaults to 25. Set to -1, float("inf") or None to return all items.
            filter: (Advanced) If the filtering available in the above is not sufficient, you can write your own filtering which will be ANDed with the filter above. {% if data_class.has_one_to_many_edges %}
            retrieve_edges: Whether to retrieve {{ data_class.one_to_many_edges_docs }} external ids for the {{ data_class.doc_list_name }}. Defaults to True.{% endif %}

        Returns:
            Aggregation results.

        Examples:

            Count {{ data_class.doc_list_name }} in space `my_space`:

                >>> from {{ top_level_package }} import {{ client_name }}
                >>> client = {{ client_name }}()
                >>> result = client.{{ api_class.client_attribute }}.aggregate("count", space="my_space")

        """

        filter_ = _create_filter(
            self._view_id,{% for parm in list_method.parameters %}
            {{ parm.name }},{% endfor %}
            filter,
        )
        return self._aggregate(
            self._view_id,
            aggregate,
            {{ data_class.properties_dict_name }},
            property,
            group_by,{% if data_class.has_text_field %}
            query,
            search_property,{% else %}
            None,
            None,{% endif %}
            limit,
            filter_,
        )

    def histogram(
        self,
        property: {{ data_class.field_names }},
        interval: float,{% if data_class.has_text_field %}
        query: str | None = None,
        search_property: {{ data_class.text_field_names }} | Sequence[{{ data_class.text_field_names }}] | None = None,{% endif %}{% for parm in list_method.parameters %}
        {{ parm.name }}: {{ parm.annotation }} = {{ parm.default }},{% endfor %}
        limit: int = DEFAULT_LIMIT_READ,
        filter: dm.Filter | None = None,
    ) -> dm.aggregations.HistogramValue:
        """Produces histograms for {{ data_class.doc_list_name }}

        Args:
            property: The property to use as the value in the histogram.
            interval: The interval to use for the histogram bins.{% if data_class.has_text_field %}
            query: The query to search for in the text field.
            search_property: The text field to search in.{% endif %}{% for parm in list_method.parameters %}
            {{ parm.name }}: {{ parm.description }}{% endfor %}
            limit: Maximum number of {{ data_class.doc_list_name }} to return. Defaults to 25. Set to -1, float("inf") or None to return all items.
            filter: (Advanced) If the filtering available in the above is not sufficient, you can write your own filtering which will be ANDed with the filter above. {% if data_class.has_one_to_many_edges %}
            retrieve_edges: Whether to retrieve {{ data_class.one_to_many_edges_docs }} external ids for the {{ data_class.doc_list_name }}. Defaults to True.{% endif %}

        Returns:
            Bucketed histogram results.

        """
        filter_ = _create_filter(
            self._view_id,{% for parm in list_method.parameters %}
            {{ parm.name }},{% endfor %}
            filter,
        )
        return self._histogram(
            self._view_id,
            property,
            interval,
            {{ data_class.properties_dict_name }},{% if data_class.has_text_field %}
            query,
            search_property,{% else %}
            None,
            None,{% endif %}
            limit,
            filter_,
        )
